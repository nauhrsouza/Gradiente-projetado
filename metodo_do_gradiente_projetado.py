# -*- coding: utf-8 -*-
"""metodo do gradiente projetado

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ir5TQOyivCaqcBSh596zTV_J0WE_Mn9D

#funções
funções usadas no método
"""

import sympy as sp
from math import*
import numpy as np
gama=1000000
eps = 10**(-5)
rho = 1
bMax = 10**8
theta1 = (3-sqrt(5))/2
theta2 = 1-theta1
eta=1/2
x,y,z,w = sp.symbols('x y z w')
sp.init_printing(use_unicode=True)

f_1 = x**2 +y**2 +z**2 +w**2 -2*x -3*w

def funcao(px, py,pz,pw):
    return  px**2 +py**2 +pz**2 +pw**2 -2*px -3*pw

def gradiente(px, py,pz,pw): 
  return [2*px-2, 2*py, 2*pz,2*pw-3]

def inv(M):
  return np.linalg.inv(M)

def matriz_restricao():
    return [[2,1,1,4],[1,1,2,1],[0,0,0,1]]
  
def matriz_id():
  return np.identity(len(matriz_restricao()[0]),dtype=int) 
  
def projecao(matriz_restri):
    return matriz_id() - np.dot(np.array(matriz_restri).T,
                                np.dot(inv(np.dot(matriz_restri,
                                np.array(matriz_restri).T)),
                                matriz_restri))
    
def multiplicador_lagrange(matriz_restri,grad):
    return -np.dot(np.dot(inv(np.dot(matriz_restri,np.array(matriz_restri).T)),
                                        matriz_restri),np.array(grad).T)

"""#Seção áurea"""

t_kmax=[]
def phi_t(t_k,x_k,d_k):
    t = x_k + np.dot(t_k, d_k)
    phi =  funcao(t[0],t[1],t[2],t[3])
    return phi
def aurea(d_k):
    #Obtenção do intervalo [a,b]
    a = 0
    s = rho
    b = 2 * rho
    phib = phi_t(b, x, d_k)
    phis = phi_t(s, x, d_k)
    while phib < phis and 2*b < bMax:
        a = s
        s = b
        b = 2*b
        phis = phib
        phib = phi_t(b, x, d_k)
    #Obtenção de t em [a,b]
    u = a + theta1 * (b - a)
    v = a + theta2 * (b - a)
    phiu = phi_t(u, x, d_k)
    phiv = phi_t(v, x, d_k)
    while (b-a) > eps:
        if phiu < phiv:
            b = v
            v = u
            u = a + theta1 * (b - a)
            phiv = phiu
            phiu = phi_t(u, x, d_k)
        else:
            a = u
            u = v
            v = a + theta2 * (b - a)
            phiu = phiv
            phiv = phi_t(v, x, d_k)
        t_k = (u+v)/2
        t_kmax.append(t_k)
    
    return t_kmax

"""#Armijo"""

def armijo(t,x_k,d_k,eta):
  t_k=t
  gd = np.dot(gradiente(x_k[0], x_k[1],x_k[2],x_k[3]), d_k)
  f = funcao(x_k[0], x_k[1],x_k[2],x_k[3])
  f_t = funcao(x_k[0] + t_k * d_k[0], x_k[1] + t_k * d_k[1],x_k[2]+t_k*d_k[2],x_k[3]+t_k*d_k[3])
  while f_t > f + eta*t_k*gd:
      t_k = gama*t_k
      f_t = funcao(x_k[0] + t_k * d_k[0], x_k[1] + t_k * d_k[1],x_k[2]+t_k*d_k[2],x_k[3]+t_k*d_k[3])
  return t_k

"""#método gradiente projetado"""

nova_matriz_restri=matriz_restricao()
x=eval(input(":"))
x_k=x
grad=gradiente(x_k[0],x_k[1],x_k[2],x_k[3])
multi_lagrange=multiplicador_lagrange(nova_matriz_restri,gradiente(x_k[0],x_k[1],x_k[2],x_k[3]))

def cal_direcao(proj,grad):
   return -np.dot(proj,grad)
    
def MGP(x_k):
  d_k=cal_direcao(projecao(nova_matriz_restri),grad)

  while np.linalg.norm(d_k)>eps:

    alpha_1=np.max(aurea(d_k))

    alpha_2=armijo(alpha_1,x_k,d_k,eta)

    x_k=x_k+np.dot(alpha_2,d_k)

    d_k= cal_direcao(projecao(nova_matriz_restri),grad)

    #return f'{np.round(x_k,5)},{np.round(d_k,5)},{alpha_1}'
  if np.min(multi_lagrange)<0:

      nova_matriz_restri=np.delete(nova_matriz_restri,np.where(np.min(multi_lagrange)), axis = 0)

      return nova_matriz_restri
  else:
      return x_k
  
MGP(x)